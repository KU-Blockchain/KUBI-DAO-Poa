// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class DDTokenCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DDTokenCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DDTokenCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DDTokenCreated", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DDTokenCreated | null {
    return changetype<DDTokenCreated | null>(
      store.get_in_block("DDTokenCreated", id)
    );
  }

  static load(id: string): DDTokenCreated | null {
    return changetype<DDTokenCreated | null>(store.get("DDTokenCreated", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenAddress(): Bytes {
    let value = this.get("tokenAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tokenAddress(value: Bytes) {
    this.set("tokenAddress", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }

  get allowedRoleNames(): DDAllowedRoleNameLoader {
    return new DDAllowedRoleNameLoader(
      "DDTokenCreated",
      this.get("id")!.toString(),
      "allowedRoleNames"
    );
  }
}

export class DDAllowedRoleName extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DDAllowedRoleName entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DDAllowedRoleName must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DDAllowedRoleName", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DDAllowedRoleName | null {
    return changetype<DDAllowedRoleName | null>(
      store.get_in_block("DDAllowedRoleName", id)
    );
  }

  static load(id: string): DDAllowedRoleName | null {
    return changetype<DDAllowedRoleName | null>(
      store.get("DDAllowedRoleName", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get roleName(): string {
    let value = this.get("roleName");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set roleName(value: string) {
    this.set("roleName", Value.fromString(value));
  }

  get tokenCreated(): string {
    let value = this.get("tokenCreated");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set tokenCreated(value: string) {
    this.set("tokenCreated", Value.fromString(value));
  }
}

export class DDToken extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DDToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DDToken must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DDToken", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DDToken | null {
    return changetype<DDToken | null>(store.get_in_block("DDToken", id));
  }

  static load(id: string): DDToken | null {
    return changetype<DDToken | null>(store.get("DDToken", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenAddress(): Bytes {
    let value = this.get("tokenAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tokenAddress(value: Bytes) {
    this.set("tokenAddress", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }

  get mintEvents(): DDTokenMintEventLoader {
    return new DDTokenMintEventLoader(
      "DDToken",
      this.get("id")!.toString(),
      "mintEvents"
    );
  }
}

export class DDTokenMintEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DDTokenMintEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DDTokenMintEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DDTokenMintEvent", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DDTokenMintEvent | null {
    return changetype<DDTokenMintEvent | null>(
      store.get_in_block("DDTokenMintEvent", id)
    );
  }

  static load(id: string): DDTokenMintEvent | null {
    return changetype<DDTokenMintEvent | null>(
      store.get("DDTokenMintEvent", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class PTTokenCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PTTokenCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PTTokenCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PTTokenCreated", id.toString(), this);
    }
  }

  static loadInBlock(id: string): PTTokenCreated | null {
    return changetype<PTTokenCreated | null>(
      store.get_in_block("PTTokenCreated", id)
    );
  }

  static load(id: string): PTTokenCreated | null {
    return changetype<PTTokenCreated | null>(store.get("PTTokenCreated", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenAddress(): Bytes {
    let value = this.get("tokenAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tokenAddress(value: Bytes) {
    this.set("tokenAddress", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }

  get allowedRoleNames(): PTAllowedRoleNameLoader {
    return new PTAllowedRoleNameLoader(
      "PTTokenCreated",
      this.get("id")!.toString(),
      "allowedRoleNames"
    );
  }
}

export class PTAllowedRoleName extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PTAllowedRoleName entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PTAllowedRoleName must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PTAllowedRoleName", id.toString(), this);
    }
  }

  static loadInBlock(id: string): PTAllowedRoleName | null {
    return changetype<PTAllowedRoleName | null>(
      store.get_in_block("PTAllowedRoleName", id)
    );
  }

  static load(id: string): PTAllowedRoleName | null {
    return changetype<PTAllowedRoleName | null>(
      store.get("PTAllowedRoleName", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get roleName(): string {
    let value = this.get("roleName");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set roleName(value: string) {
    this.set("roleName", Value.fromString(value));
  }

  get tokenCreated(): string {
    let value = this.get("tokenCreated");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set tokenCreated(value: string) {
    this.set("tokenCreated", Value.fromString(value));
  }
}

export class PTToken extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PTToken entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PTToken must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PTToken", id.toString(), this);
    }
  }

  static loadInBlock(id: string): PTToken | null {
    return changetype<PTToken | null>(store.get_in_block("PTToken", id));
  }

  static load(id: string): PTToken | null {
    return changetype<PTToken | null>(store.get("PTToken", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get tokenAddress(): Bytes {
    let value = this.get("tokenAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set tokenAddress(value: Bytes) {
    this.set("tokenAddress", Value.fromBytes(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get symbol(): string {
    let value = this.get("symbol");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set symbol(value: string) {
    this.set("symbol", Value.fromString(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }

  get mintEvents(): PTTokenMintEventLoader {
    return new PTTokenMintEventLoader(
      "PTToken",
      this.get("id")!.toString(),
      "mintEvents"
    );
  }

  get taskManagerAddress(): Bytes | null {
    let value = this.get("taskManagerAddress");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set taskManagerAddress(value: Bytes | null) {
    if (!value) {
      this.unset("taskManagerAddress");
    } else {
      this.set("taskManagerAddress", Value.fromBytes(<Bytes>value));
    }
  }
}

export class PTTokenMintEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PTTokenMintEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PTTokenMintEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PTTokenMintEvent", id.toString(), this);
    }
  }

  static loadInBlock(id: string): PTTokenMintEvent | null {
    return changetype<PTTokenMintEvent | null>(
      store.get_in_block("PTTokenMintEvent", id)
    );
  }

  static load(id: string): PTTokenMintEvent | null {
    return changetype<PTTokenMintEvent | null>(
      store.get("PTTokenMintEvent", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get token(): string {
    let value = this.get("token");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set token(value: string) {
    this.set("token", Value.fromString(value));
  }

  get to(): Bytes {
    let value = this.get("to");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set to(value: Bytes) {
    this.set("to", Value.fromBytes(value));
  }

  get amount(): BigInt {
    let value = this.get("amount");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set amount(value: BigInt) {
    this.set("amount", Value.fromBigInt(value));
  }
}

export class NFTMembershipCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NFTMembershipCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NFTMembershipCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NFTMembershipCreated", id.toString(), this);
    }
  }

  static loadInBlock(id: string): NFTMembershipCreated | null {
    return changetype<NFTMembershipCreated | null>(
      store.get_in_block("NFTMembershipCreated", id)
    );
  }

  static load(id: string): NFTMembershipCreated | null {
    return changetype<NFTMembershipCreated | null>(
      store.get("NFTMembershipCreated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get memberTypeNames(): Array<string> {
    let value = this.get("memberTypeNames");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toStringArray();
    }
  }

  set memberTypeNames(value: Array<string>) {
    this.set("memberTypeNames", Value.fromStringArray(value));
  }

  get executiveRoles(): Array<string> {
    let value = this.get("executiveRoles");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toStringArray();
    }
  }

  set executiveRoles(value: Array<string>) {
    this.set("executiveRoles", Value.fromStringArray(value));
  }

  get defaultImageURL(): string {
    let value = this.get("defaultImageURL");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set defaultImageURL(value: string) {
    this.set("defaultImageURL", Value.fromString(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }
}

export class NFTMembership extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NFTMembership entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NFTMembership must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NFTMembership", id.toString(), this);
    }
  }

  static loadInBlock(id: string): NFTMembership | null {
    return changetype<NFTMembership | null>(
      store.get_in_block("NFTMembership", id)
    );
  }

  static load(id: string): NFTMembership | null {
    return changetype<NFTMembership | null>(store.get("NFTMembership", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }

  get memberTypeNames(): Array<string> {
    let value = this.get("memberTypeNames");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toStringArray();
    }
  }

  set memberTypeNames(value: Array<string>) {
    this.set("memberTypeNames", Value.fromStringArray(value));
  }

  get executiveRoles(): Array<string> {
    let value = this.get("executiveRoles");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toStringArray();
    }
  }

  set executiveRoles(value: Array<string>) {
    this.set("executiveRoles", Value.fromStringArray(value));
  }

  get defaultImageURL(): string {
    let value = this.get("defaultImageURL");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set defaultImageURL(value: string) {
    this.set("defaultImageURL", Value.fromString(value));
  }

  get mintEvents(): NFTMintEventLoader {
    return new NFTMintEventLoader(
      "NFTMembership",
      this.get("id")!.toString(),
      "mintEvents"
    );
  }

  get changeTypeEvents(): NFTChangeTypeEventLoader {
    return new NFTChangeTypeEventLoader(
      "NFTMembership",
      this.get("id")!.toString(),
      "changeTypeEvents"
    );
  }
}

export class NFTMemberType extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NFTMemberType entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NFTMemberType must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NFTMemberType", id.toString(), this);
    }
  }

  static loadInBlock(id: string): NFTMemberType | null {
    return changetype<NFTMemberType | null>(
      store.get_in_block("NFTMemberType", id)
    );
  }

  static load(id: string): NFTMemberType | null {
    return changetype<NFTMemberType | null>(store.get("NFTMemberType", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get memberTypeName(): string {
    let value = this.get("memberTypeName");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set memberTypeName(value: string) {
    this.set("memberTypeName", Value.fromString(value));
  }

  get imageURL(): string {
    let value = this.get("imageURL");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set imageURL(value: string) {
    this.set("imageURL", Value.fromString(value));
  }

  get membership(): string {
    let value = this.get("membership");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set membership(value: string) {
    this.set("membership", Value.fromString(value));
  }
}

export class NFTMintEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NFTMintEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NFTMintEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NFTMintEvent", id.toString(), this);
    }
  }

  static loadInBlock(id: string): NFTMintEvent | null {
    return changetype<NFTMintEvent | null>(
      store.get_in_block("NFTMintEvent", id)
    );
  }

  static load(id: string): NFTMintEvent | null {
    return changetype<NFTMintEvent | null>(store.get("NFTMintEvent", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get membership(): string {
    let value = this.get("membership");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set membership(value: string) {
    this.set("membership", Value.fromString(value));
  }

  get recipient(): Bytes {
    let value = this.get("recipient");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set recipient(value: Bytes) {
    this.set("recipient", Value.fromBytes(value));
  }

  get memberTypeName(): string {
    let value = this.get("memberTypeName");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set memberTypeName(value: string) {
    this.set("memberTypeName", Value.fromString(value));
  }

  get tokenURI(): string {
    let value = this.get("tokenURI");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set tokenURI(value: string) {
    this.set("tokenURI", Value.fromString(value));
  }
}

export class NFTChangeTypeEvent extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save NFTChangeTypeEvent entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type NFTChangeTypeEvent must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("NFTChangeTypeEvent", id.toString(), this);
    }
  }

  static loadInBlock(id: string): NFTChangeTypeEvent | null {
    return changetype<NFTChangeTypeEvent | null>(
      store.get_in_block("NFTChangeTypeEvent", id)
    );
  }

  static load(id: string): NFTChangeTypeEvent | null {
    return changetype<NFTChangeTypeEvent | null>(
      store.get("NFTChangeTypeEvent", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get membership(): string {
    let value = this.get("membership");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set membership(value: string) {
    this.set("membership", Value.fromString(value));
  }

  get user(): Bytes {
    let value = this.get("user");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set user(value: Bytes) {
    this.set("user", Value.fromBytes(value));
  }

  get newMemberType(): string {
    let value = this.get("newMemberType");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set newMemberType(value: string) {
    this.set("newMemberType", Value.fromString(value));
  }
}

export class Treasury extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Treasury entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Treasury must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Treasury", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Treasury | null {
    return changetype<Treasury | null>(store.get_in_block("Treasury", id));
  }

  static load(id: string): Treasury | null {
    return changetype<Treasury | null>(store.get("Treasury", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }

  get treasuryAddress(): Bytes {
    let value = this.get("treasuryAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set treasuryAddress(value: Bytes) {
    this.set("treasuryAddress", Value.fromBytes(value));
  }

  get votingContract(): Bytes | null {
    let value = this.get("votingContract");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set votingContract(value: Bytes | null) {
    if (!value) {
      this.unset("votingContract");
    } else {
      this.set("votingContract", Value.fromBytes(<Bytes>value));
    }
  }
}

export class TreasuryCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TreasuryCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TreasuryCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TreasuryCreated", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TreasuryCreated | null {
    return changetype<TreasuryCreated | null>(
      store.get_in_block("TreasuryCreated", id)
    );
  }

  static load(id: string): TreasuryCreated | null {
    return changetype<TreasuryCreated | null>(store.get("TreasuryCreated", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }

  get treasuryAddress(): Bytes {
    let value = this.get("treasuryAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set treasuryAddress(value: Bytes) {
    this.set("treasuryAddress", Value.fromBytes(value));
  }
}

export class PTVotingCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PTVotingCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PTVotingCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PTVotingCreated", id.toString(), this);
    }
  }

  static loadInBlock(id: string): PTVotingCreated | null {
    return changetype<PTVotingCreated | null>(
      store.get_in_block("PTVotingCreated", id)
    );
  }

  static load(id: string): PTVotingCreated | null {
    return changetype<PTVotingCreated | null>(store.get("PTVotingCreated", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }
}

export class PTVoting extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PTVoting entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PTVoting must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PTVoting", id.toString(), this);
    }
  }

  static loadInBlock(id: string): PTVoting | null {
    return changetype<PTVoting | null>(store.get_in_block("PTVoting", id));
  }

  static load(id: string): PTVoting | null {
    return changetype<PTVoting | null>(store.get("PTVoting", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): string {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set contract(value: string) {
    this.set("contract", Value.fromString(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }

  get proposals(): PTProposalLoader {
    return new PTProposalLoader(
      "PTVoting",
      this.get("id")!.toString(),
      "proposals"
    );
  }
}

export class PTProposal extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PTProposal entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PTProposal must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PTProposal", id.toString(), this);
    }
  }

  static loadInBlock(id: string): PTProposal | null {
    return changetype<PTProposal | null>(store.get_in_block("PTProposal", id));
  }

  static load(id: string): PTProposal | null {
    return changetype<PTProposal | null>(store.get("PTProposal", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get voting(): string {
    let value = this.get("voting");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set voting(value: string) {
    this.set("voting", Value.fromString(value));
  }

  get description(): string {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set description(value: string) {
    this.set("description", Value.fromString(value));
  }

  get totalVotes(): BigInt {
    let value = this.get("totalVotes");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalVotes(value: BigInt) {
    this.set("totalVotes", Value.fromBigInt(value));
  }

  get timeInMinutes(): BigInt {
    let value = this.get("timeInMinutes");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timeInMinutes(value: BigInt) {
    this.set("timeInMinutes", Value.fromBigInt(value));
  }

  get creationTimestamp(): BigInt {
    let value = this.get("creationTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set creationTimestamp(value: BigInt) {
    this.set("creationTimestamp", Value.fromBigInt(value));
  }

  get experationTimestamp(): BigInt {
    let value = this.get("experationTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set experationTimestamp(value: BigInt) {
    this.set("experationTimestamp", Value.fromBigInt(value));
  }

  get transferTriggerOptionIndex(): BigInt | null {
    let value = this.get("transferTriggerOptionIndex");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set transferTriggerOptionIndex(value: BigInt | null) {
    if (!value) {
      this.unset("transferTriggerOptionIndex");
    } else {
      this.set("transferTriggerOptionIndex", Value.fromBigInt(<BigInt>value));
    }
  }

  get transferRecipient(): Bytes | null {
    let value = this.get("transferRecipient");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set transferRecipient(value: Bytes | null) {
    if (!value) {
      this.unset("transferRecipient");
    } else {
      this.set("transferRecipient", Value.fromBytes(<Bytes>value));
    }
  }

  get transferAmount(): BigInt | null {
    let value = this.get("transferAmount");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set transferAmount(value: BigInt | null) {
    if (!value) {
      this.unset("transferAmount");
    } else {
      this.set("transferAmount", Value.fromBigInt(<BigInt>value));
    }
  }

  get transferEnabled(): boolean {
    let value = this.get("transferEnabled");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set transferEnabled(value: boolean) {
    this.set("transferEnabled", Value.fromBoolean(value));
  }

  get options(): PTPollOptionLoader {
    return new PTPollOptionLoader(
      "PTProposal",
      this.get("id")!.toString(),
      "options"
    );
  }

  get votes(): PTVoteLoader {
    return new PTVoteLoader("PTProposal", this.get("id")!.toString(), "votes");
  }

  get winningOptionIndex(): BigInt | null {
    let value = this.get("winningOptionIndex");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set winningOptionIndex(value: BigInt | null) {
    if (!value) {
      this.unset("winningOptionIndex");
    } else {
      this.set("winningOptionIndex", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class PTPollOption extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PTPollOption entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PTPollOption must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PTPollOption", id.toString(), this);
    }
  }

  static loadInBlock(id: string): PTPollOption | null {
    return changetype<PTPollOption | null>(
      store.get_in_block("PTPollOption", id)
    );
  }

  static load(id: string): PTPollOption | null {
    return changetype<PTPollOption | null>(store.get("PTPollOption", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get votes(): BigInt {
    let value = this.get("votes");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set votes(value: BigInt) {
    this.set("votes", Value.fromBigInt(value));
  }
}

export class PTVote extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save PTVote entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PTVote must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PTVote", id.toString(), this);
    }
  }

  static loadInBlock(id: string): PTVote | null {
    return changetype<PTVote | null>(store.get_in_block("PTVote", id));
  }

  static load(id: string): PTVote | null {
    return changetype<PTVote | null>(store.get("PTVote", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get voter(): string | null {
    let value = this.get("voter");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set voter(value: string | null) {
    if (!value) {
      this.unset("voter");
    } else {
      this.set("voter", Value.fromString(<string>value));
    }
  }

  get optionIndex(): BigInt {
    let value = this.get("optionIndex");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set optionIndex(value: BigInt) {
    this.set("optionIndex", Value.fromBigInt(value));
  }

  get voteWeight(): BigInt {
    let value = this.get("voteWeight");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set voteWeight(value: BigInt) {
    this.set("voteWeight", Value.fromBigInt(value));
  }
}

export class DDVotingCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DDVotingCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DDVotingCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DDVotingCreated", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DDVotingCreated | null {
    return changetype<DDVotingCreated | null>(
      store.get_in_block("DDVotingCreated", id)
    );
  }

  static load(id: string): DDVotingCreated | null {
    return changetype<DDVotingCreated | null>(store.get("DDVotingCreated", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }
}

export class DDVoting extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DDVoting entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DDVoting must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DDVoting", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DDVoting | null {
    return changetype<DDVoting | null>(store.get_in_block("DDVoting", id));
  }

  static load(id: string): DDVoting | null {
    return changetype<DDVoting | null>(store.get("DDVoting", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): string {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set contract(value: string) {
    this.set("contract", Value.fromString(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }

  get proposals(): DDProposalLoader {
    return new DDProposalLoader(
      "DDVoting",
      this.get("id")!.toString(),
      "proposals"
    );
  }
}

export class DDProposal extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DDProposal entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DDProposal must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DDProposal", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DDProposal | null {
    return changetype<DDProposal | null>(store.get_in_block("DDProposal", id));
  }

  static load(id: string): DDProposal | null {
    return changetype<DDProposal | null>(store.get("DDProposal", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get voting(): string {
    let value = this.get("voting");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set voting(value: string) {
    this.set("voting", Value.fromString(value));
  }

  get description(): string {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set description(value: string) {
    this.set("description", Value.fromString(value));
  }

  get totalVotes(): BigInt {
    let value = this.get("totalVotes");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalVotes(value: BigInt) {
    this.set("totalVotes", Value.fromBigInt(value));
  }

  get timeInMinutes(): BigInt {
    let value = this.get("timeInMinutes");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timeInMinutes(value: BigInt) {
    this.set("timeInMinutes", Value.fromBigInt(value));
  }

  get creationTimestamp(): BigInt {
    let value = this.get("creationTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set creationTimestamp(value: BigInt) {
    this.set("creationTimestamp", Value.fromBigInt(value));
  }

  get experationTimestamp(): BigInt {
    let value = this.get("experationTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set experationTimestamp(value: BigInt) {
    this.set("experationTimestamp", Value.fromBigInt(value));
  }

  get transferTriggerOptionIndex(): BigInt | null {
    let value = this.get("transferTriggerOptionIndex");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set transferTriggerOptionIndex(value: BigInt | null) {
    if (!value) {
      this.unset("transferTriggerOptionIndex");
    } else {
      this.set("transferTriggerOptionIndex", Value.fromBigInt(<BigInt>value));
    }
  }

  get transferRecipient(): Bytes | null {
    let value = this.get("transferRecipient");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set transferRecipient(value: Bytes | null) {
    if (!value) {
      this.unset("transferRecipient");
    } else {
      this.set("transferRecipient", Value.fromBytes(<Bytes>value));
    }
  }

  get transferAmount(): BigInt | null {
    let value = this.get("transferAmount");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set transferAmount(value: BigInt | null) {
    if (!value) {
      this.unset("transferAmount");
    } else {
      this.set("transferAmount", Value.fromBigInt(<BigInt>value));
    }
  }

  get transferEnabled(): boolean {
    let value = this.get("transferEnabled");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set transferEnabled(value: boolean) {
    this.set("transferEnabled", Value.fromBoolean(value));
  }

  get options(): DDPollOptionLoader {
    return new DDPollOptionLoader(
      "DDProposal",
      this.get("id")!.toString(),
      "options"
    );
  }

  get votes(): DDVoteLoader {
    return new DDVoteLoader("DDProposal", this.get("id")!.toString(), "votes");
  }

  get winningOptionIndex(): BigInt | null {
    let value = this.get("winningOptionIndex");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set winningOptionIndex(value: BigInt | null) {
    if (!value) {
      this.unset("winningOptionIndex");
    } else {
      this.set("winningOptionIndex", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class DDPollOption extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DDPollOption entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DDPollOption must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DDPollOption", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DDPollOption | null {
    return changetype<DDPollOption | null>(
      store.get_in_block("DDPollOption", id)
    );
  }

  static load(id: string): DDPollOption | null {
    return changetype<DDPollOption | null>(store.get("DDPollOption", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get votes(): BigInt {
    let value = this.get("votes");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set votes(value: BigInt) {
    this.set("votes", Value.fromBigInt(value));
  }
}

export class DDVote extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save DDVote entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type DDVote must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("DDVote", id.toString(), this);
    }
  }

  static loadInBlock(id: string): DDVote | null {
    return changetype<DDVote | null>(store.get_in_block("DDVote", id));
  }

  static load(id: string): DDVote | null {
    return changetype<DDVote | null>(store.get("DDVote", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get optionIndex(): BigInt {
    let value = this.get("optionIndex");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set optionIndex(value: BigInt) {
    this.set("optionIndex", Value.fromBigInt(value));
  }

  get voteWeight(): BigInt {
    let value = this.get("voteWeight");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set voteWeight(value: BigInt) {
    this.set("voteWeight", Value.fromBigInt(value));
  }

  get voter(): string | null {
    let value = this.get("voter");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set voter(value: string | null) {
    if (!value) {
      this.unset("voter");
    } else {
      this.set("voter", Value.fromString(<string>value));
    }
  }
}

export class HybridVotingCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save HybridVotingCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type HybridVotingCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("HybridVotingCreated", id.toString(), this);
    }
  }

  static loadInBlock(id: string): HybridVotingCreated | null {
    return changetype<HybridVotingCreated | null>(
      store.get_in_block("HybridVotingCreated", id)
    );
  }

  static load(id: string): HybridVotingCreated | null {
    return changetype<HybridVotingCreated | null>(
      store.get("HybridVotingCreated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }
}

export class HybridVoting extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save HybridVoting entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type HybridVoting must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("HybridVoting", id.toString(), this);
    }
  }

  static loadInBlock(id: string): HybridVoting | null {
    return changetype<HybridVoting | null>(
      store.get_in_block("HybridVoting", id)
    );
  }

  static load(id: string): HybridVoting | null {
    return changetype<HybridVoting | null>(store.get("HybridVoting", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): string {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set contract(value: string) {
    this.set("contract", Value.fromString(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }

  get proposals(): HybridProposalLoader {
    return new HybridProposalLoader(
      "HybridVoting",
      this.get("id")!.toString(),
      "proposals"
    );
  }
}

export class HybridProposal extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save HybridProposal entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type HybridProposal must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("HybridProposal", id.toString(), this);
    }
  }

  static loadInBlock(id: string): HybridProposal | null {
    return changetype<HybridProposal | null>(
      store.get_in_block("HybridProposal", id)
    );
  }

  static load(id: string): HybridProposal | null {
    return changetype<HybridProposal | null>(store.get("HybridProposal", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get voting(): string {
    let value = this.get("voting");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set voting(value: string) {
    this.set("voting", Value.fromString(value));
  }

  get description(): string {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set description(value: string) {
    this.set("description", Value.fromString(value));
  }

  get totalVotes(): BigInt {
    let value = this.get("totalVotes");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set totalVotes(value: BigInt) {
    this.set("totalVotes", Value.fromBigInt(value));
  }

  get timeInMinutes(): BigInt {
    let value = this.get("timeInMinutes");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set timeInMinutes(value: BigInt) {
    this.set("timeInMinutes", Value.fromBigInt(value));
  }

  get creationTimestamp(): BigInt {
    let value = this.get("creationTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set creationTimestamp(value: BigInt) {
    this.set("creationTimestamp", Value.fromBigInt(value));
  }

  get experationTimestamp(): BigInt {
    let value = this.get("experationTimestamp");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set experationTimestamp(value: BigInt) {
    this.set("experationTimestamp", Value.fromBigInt(value));
  }

  get transferTriggerOptionIndex(): BigInt | null {
    let value = this.get("transferTriggerOptionIndex");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set transferTriggerOptionIndex(value: BigInt | null) {
    if (!value) {
      this.unset("transferTriggerOptionIndex");
    } else {
      this.set("transferTriggerOptionIndex", Value.fromBigInt(<BigInt>value));
    }
  }

  get transferRecipient(): Bytes | null {
    let value = this.get("transferRecipient");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set transferRecipient(value: Bytes | null) {
    if (!value) {
      this.unset("transferRecipient");
    } else {
      this.set("transferRecipient", Value.fromBytes(<Bytes>value));
    }
  }

  get transferAmount(): BigInt | null {
    let value = this.get("transferAmount");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set transferAmount(value: BigInt | null) {
    if (!value) {
      this.unset("transferAmount");
    } else {
      this.set("transferAmount", Value.fromBigInt(<BigInt>value));
    }
  }

  get transferEnabled(): boolean {
    let value = this.get("transferEnabled");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set transferEnabled(value: boolean) {
    this.set("transferEnabled", Value.fromBoolean(value));
  }

  get options(): HybridPollOptionLoader {
    return new HybridPollOptionLoader(
      "HybridProposal",
      this.get("id")!.toString(),
      "options"
    );
  }

  get votes(): HybridVoteLoader {
    return new HybridVoteLoader(
      "HybridProposal",
      this.get("id")!.toString(),
      "votes"
    );
  }

  get winningOptionIndex(): BigInt | null {
    let value = this.get("winningOptionIndex");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBigInt();
    }
  }

  set winningOptionIndex(value: BigInt | null) {
    if (!value) {
      this.unset("winningOptionIndex");
    } else {
      this.set("winningOptionIndex", Value.fromBigInt(<BigInt>value));
    }
  }
}

export class HybridPollOption extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save HybridPollOption entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type HybridPollOption must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("HybridPollOption", id.toString(), this);
    }
  }

  static loadInBlock(id: string): HybridPollOption | null {
    return changetype<HybridPollOption | null>(
      store.get_in_block("HybridPollOption", id)
    );
  }

  static load(id: string): HybridPollOption | null {
    return changetype<HybridPollOption | null>(
      store.get("HybridPollOption", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get votes(): BigInt {
    let value = this.get("votes");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set votes(value: BigInt) {
    this.set("votes", Value.fromBigInt(value));
  }
}

export class HybridVote extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save HybridVote entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type HybridVote must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("HybridVote", id.toString(), this);
    }
  }

  static loadInBlock(id: string): HybridVote | null {
    return changetype<HybridVote | null>(store.get_in_block("HybridVote", id));
  }

  static load(id: string): HybridVote | null {
    return changetype<HybridVote | null>(store.get("HybridVote", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get proposal(): string {
    let value = this.get("proposal");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set proposal(value: string) {
    this.set("proposal", Value.fromString(value));
  }

  get voter(): string | null {
    let value = this.get("voter");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set voter(value: string | null) {
    if (!value) {
      this.unset("voter");
    } else {
      this.set("voter", Value.fromString(<string>value));
    }
  }

  get optionIndex(): BigInt {
    let value = this.get("optionIndex");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set optionIndex(value: BigInt) {
    this.set("optionIndex", Value.fromBigInt(value));
  }

  get voteWeightPT(): BigInt {
    let value = this.get("voteWeightPT");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set voteWeightPT(value: BigInt) {
    this.set("voteWeightPT", Value.fromBigInt(value));
  }

  get voteWeightDD(): BigInt {
    let value = this.get("voteWeightDD");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set voteWeightDD(value: BigInt) {
    this.set("voteWeightDD", Value.fromBigInt(value));
  }
}

export class TaskManagerCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TaskManagerCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TaskManagerCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TaskManagerCreated", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TaskManagerCreated | null {
    return changetype<TaskManagerCreated | null>(
      store.get_in_block("TaskManagerCreated", id)
    );
  }

  static load(id: string): TaskManagerCreated | null {
    return changetype<TaskManagerCreated | null>(
      store.get("TaskManagerCreated", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }
}

export class TaskManager extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save TaskManager entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type TaskManager must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("TaskManager", id.toString(), this);
    }
  }

  static loadInBlock(id: string): TaskManager | null {
    return changetype<TaskManager | null>(
      store.get_in_block("TaskManager", id)
    );
  }

  static load(id: string): TaskManager | null {
    return changetype<TaskManager | null>(store.get("TaskManager", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): string {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set contract(value: string) {
    this.set("contract", Value.fromString(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }

  get projects(): ProjectLoader {
    return new ProjectLoader(
      "TaskManager",
      this.get("id")!.toString(),
      "projects"
    );
  }
}

export class Task extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Task entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Task must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Task", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Task | null {
    return changetype<Task | null>(store.get_in_block("Task", id));
  }

  static load(id: string): Task | null {
    return changetype<Task | null>(store.get("Task", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get taskManager(): string {
    let value = this.get("taskManager");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set taskManager(value: string) {
    this.set("taskManager", Value.fromString(value));
  }

  get ipfsHash(): string {
    let value = this.get("ipfsHash");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set ipfsHash(value: string) {
    this.set("ipfsHash", Value.fromString(value));
  }

  get payout(): BigInt {
    let value = this.get("payout");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set payout(value: BigInt) {
    this.set("payout", Value.fromBigInt(value));
  }

  get project(): string {
    let value = this.get("project");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set project(value: string) {
    this.set("project", Value.fromString(value));
  }

  get claimer(): Bytes | null {
    let value = this.get("claimer");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set claimer(value: Bytes | null) {
    if (!value) {
      this.unset("claimer");
    } else {
      this.set("claimer", Value.fromBytes(<Bytes>value));
    }
  }

  get completed(): boolean {
    let value = this.get("completed");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set completed(value: boolean) {
    this.set("completed", Value.fromBoolean(value));
  }

  get user(): string | null {
    let value = this.get("user");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set user(value: string | null) {
    if (!value) {
      this.unset("user");
    } else {
      this.set("user", Value.fromString(<string>value));
    }
  }
}

export class Project extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Project entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Project must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Project", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Project | null {
    return changetype<Project | null>(store.get_in_block("Project", id));
  }

  static load(id: string): Project | null {
    return changetype<Project | null>(store.get("Project", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get taskManager(): string {
    let value = this.get("taskManager");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set taskManager(value: string) {
    this.set("taskManager", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get tasks(): TaskLoader {
    return new TaskLoader("Project", this.get("id")!.toString(), "tasks");
  }

  get deleted(): boolean {
    let value = this.get("deleted");
    if (!value || value.kind == ValueKind.NULL) {
      return false;
    } else {
      return value.toBoolean();
    }
  }

  set deleted(value: boolean) {
    this.set("deleted", Value.fromBoolean(value));
  }
}

export class RegistryCreated extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save RegistryCreated entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type RegistryCreated must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("RegistryCreated", id.toString(), this);
    }
  }

  static loadInBlock(id: string): RegistryCreated | null {
    return changetype<RegistryCreated | null>(
      store.get_in_block("RegistryCreated", id)
    );
  }

  static load(id: string): RegistryCreated | null {
    return changetype<RegistryCreated | null>(store.get("RegistryCreated", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }
}

export class Registry extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Registry entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Registry must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Registry", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Registry | null {
    return changetype<Registry | null>(store.get_in_block("Registry", id));
  }

  static load(id: string): Registry | null {
    return changetype<Registry | null>(store.get("Registry", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contract(): string {
    let value = this.get("contract");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set contract(value: string) {
    this.set("contract", Value.fromString(value));
  }

  get POname(): string {
    let value = this.get("POname");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set POname(value: string) {
    this.set("POname", Value.fromString(value));
  }

  get votingContract(): Bytes | null {
    let value = this.get("votingContract");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toBytes();
    }
  }

  set votingContract(value: Bytes | null) {
    if (!value) {
      this.unset("votingContract");
    } else {
      this.set("votingContract", Value.fromBytes(<Bytes>value));
    }
  }

  get validContracts(): ValidContractLoader {
    return new ValidContractLoader(
      "Registry",
      this.get("id")!.toString(),
      "validContracts"
    );
  }

  get logoURL(): string | null {
    let value = this.get("logoURL");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set logoURL(value: string | null) {
    if (!value) {
      this.unset("logoURL");
    } else {
      this.set("logoURL", Value.fromString(<string>value));
    }
  }
}

export class ValidContract extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save ValidContract entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type ValidContract must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("ValidContract", id.toString(), this);
    }
  }

  static loadInBlock(id: string): ValidContract | null {
    return changetype<ValidContract | null>(
      store.get_in_block("ValidContract", id)
    );
  }

  static load(id: string): ValidContract | null {
    return changetype<ValidContract | null>(store.get("ValidContract", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get contractAddress(): Bytes {
    let value = this.get("contractAddress");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set contractAddress(value: Bytes) {
    this.set("contractAddress", Value.fromBytes(value));
  }

  get registry(): string {
    let value = this.get("registry");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set registry(value: string) {
    this.set("registry", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }
}

export class PerpetualOrganization extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(
      id != null,
      "Cannot save PerpetualOrganization entity without an ID"
    );
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type PerpetualOrganization must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("PerpetualOrganization", id.toString(), this);
    }
  }

  static loadInBlock(id: string): PerpetualOrganization | null {
    return changetype<PerpetualOrganization | null>(
      store.get_in_block("PerpetualOrganization", id)
    );
  }

  static load(id: string): PerpetualOrganization | null {
    return changetype<PerpetualOrganization | null>(
      store.get("PerpetualOrganization", id)
    );
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get description(): string | null {
    let value = this.get("description");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set description(value: string | null) {
    if (!value) {
      this.unset("description");
    } else {
      this.set("description", Value.fromString(<string>value));
    }
  }

  get constitution(): string | null {
    let value = this.get("constitution");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set constitution(value: string | null) {
    if (!value) {
      this.unset("constitution");
    } else {
      this.set("constitution", Value.fromString(<string>value));
    }
  }

  get logoURL(): string | null {
    let value = this.get("logoURL");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set logoURL(value: string | null) {
    if (!value) {
      this.unset("logoURL");
    } else {
      this.set("logoURL", Value.fromString(<string>value));
    }
  }

  get NFTMembership(): string {
    let value = this.get("NFTMembership");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set NFTMembership(value: string) {
    this.set("NFTMembership", Value.fromString(value));
  }

  get registry(): string | null {
    let value = this.get("registry");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set registry(value: string | null) {
    if (!value) {
      this.unset("registry");
    } else {
      this.set("registry", Value.fromString(<string>value));
    }
  }

  get DirectDemocracyToken(): string | null {
    let value = this.get("DirectDemocracyToken");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set DirectDemocracyToken(value: string | null) {
    if (!value) {
      this.unset("DirectDemocracyToken");
    } else {
      this.set("DirectDemocracyToken", Value.fromString(<string>value));
    }
  }

  get ParticipationToken(): string | null {
    let value = this.get("ParticipationToken");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set ParticipationToken(value: string | null) {
    if (!value) {
      this.unset("ParticipationToken");
    } else {
      this.set("ParticipationToken", Value.fromString(<string>value));
    }
  }

  get Treasury(): string | null {
    let value = this.get("Treasury");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set Treasury(value: string | null) {
    if (!value) {
      this.unset("Treasury");
    } else {
      this.set("Treasury", Value.fromString(<string>value));
    }
  }

  get TaskManager(): string | null {
    let value = this.get("TaskManager");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set TaskManager(value: string | null) {
    if (!value) {
      this.unset("TaskManager");
    } else {
      this.set("TaskManager", Value.fromString(<string>value));
    }
  }

  get ParticipationVoting(): string | null {
    let value = this.get("ParticipationVoting");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set ParticipationVoting(value: string | null) {
    if (!value) {
      this.unset("ParticipationVoting");
    } else {
      this.set("ParticipationVoting", Value.fromString(<string>value));
    }
  }

  get DirectDemocracyVoting(): string | null {
    let value = this.get("DirectDemocracyVoting");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set DirectDemocracyVoting(value: string | null) {
    if (!value) {
      this.unset("DirectDemocracyVoting");
    } else {
      this.set("DirectDemocracyVoting", Value.fromString(<string>value));
    }
  }

  get HybridVoting(): string | null {
    let value = this.get("HybridVoting");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set HybridVoting(value: string | null) {
    if (!value) {
      this.unset("HybridVoting");
    } else {
      this.set("HybridVoting", Value.fromString(<string>value));
    }
  }

  get Users(): UserLoader {
    return new UserLoader(
      "PerpetualOrganization",
      this.get("id")!.toString(),
      "Users"
    );
  }
}

export class User extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save User entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type User must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("User", id.toString(), this);
    }
  }

  static loadInBlock(id: string): User | null {
    return changetype<User | null>(store.get_in_block("User", id));
  }

  static load(id: string): User | null {
    return changetype<User | null>(store.get("User", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get organization(): string {
    let value = this.get("organization");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set organization(value: string) {
    this.set("organization", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get ddTokenBalance(): BigInt {
    let value = this.get("ddTokenBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set ddTokenBalance(value: BigInt) {
    this.set("ddTokenBalance", Value.fromBigInt(value));
  }

  get ptTokenBalance(): BigInt {
    let value = this.get("ptTokenBalance");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBigInt();
    }
  }

  set ptTokenBalance(value: BigInt) {
    this.set("ptTokenBalance", Value.fromBigInt(value));
  }

  get memberType(): string | null {
    let value = this.get("memberType");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set memberType(value: string | null) {
    if (!value) {
      this.unset("memberType");
    } else {
      this.set("memberType", Value.fromString(<string>value));
    }
  }

  get tasks(): TaskLoader {
    return new TaskLoader("User", this.get("id")!.toString(), "tasks");
  }

  get ptVotes(): PTVoteLoader {
    return new PTVoteLoader("User", this.get("id")!.toString(), "ptVotes");
  }

  get ddVotes(): DDVoteLoader {
    return new DDVoteLoader("User", this.get("id")!.toString(), "ddVotes");
  }

  get hybridVotes(): HybridVoteLoader {
    return new HybridVoteLoader(
      "User",
      this.get("id")!.toString(),
      "hybridVotes"
    );
  }

  get Account(): string | null {
    let value = this.get("Account");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set Account(value: string | null) {
    if (!value) {
      this.unset("Account");
    } else {
      this.set("Account", Value.fromString(<string>value));
    }
  }
}

export class Account extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Account entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        `Entities of type Account must have an ID of type String but the id '${id.displayData()}' is of type ${id.displayKind()}`
      );
      store.set("Account", id.toString(), this);
    }
  }

  static loadInBlock(id: string): Account | null {
    return changetype<Account | null>(store.get_in_block("Account", id));
  }

  static load(id: string): Account | null {
    return changetype<Account | null>(store.get("Account", id));
  }

  get id(): string {
    let value = this.get("id");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toString();
    }
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get address(): Bytes {
    let value = this.get("address");
    if (!value || value.kind == ValueKind.NULL) {
      throw new Error("Cannot return null for a required field.");
    } else {
      return value.toBytes();
    }
  }

  set address(value: Bytes) {
    this.set("address", Value.fromBytes(value));
  }

  get userName(): string | null {
    let value = this.get("userName");
    if (!value || value.kind == ValueKind.NULL) {
      return null;
    } else {
      return value.toString();
    }
  }

  set userName(value: string | null) {
    if (!value) {
      this.unset("userName");
    } else {
      this.set("userName", Value.fromString(<string>value));
    }
  }

  get users(): UserLoader {
    return new UserLoader("Account", this.get("id")!.toString(), "users");
  }
}

export class DDAllowedRoleNameLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): DDAllowedRoleName[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<DDAllowedRoleName[]>(value);
  }
}

export class DDTokenMintEventLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): DDTokenMintEvent[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<DDTokenMintEvent[]>(value);
  }
}

export class PTAllowedRoleNameLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): PTAllowedRoleName[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<PTAllowedRoleName[]>(value);
  }
}

export class PTTokenMintEventLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): PTTokenMintEvent[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<PTTokenMintEvent[]>(value);
  }
}

export class NFTMintEventLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): NFTMintEvent[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<NFTMintEvent[]>(value);
  }
}

export class NFTChangeTypeEventLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): NFTChangeTypeEvent[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<NFTChangeTypeEvent[]>(value);
  }
}

export class PTProposalLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): PTProposal[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<PTProposal[]>(value);
  }
}

export class PTPollOptionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): PTPollOption[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<PTPollOption[]>(value);
  }
}

export class PTVoteLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): PTVote[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<PTVote[]>(value);
  }
}

export class DDProposalLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): DDProposal[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<DDProposal[]>(value);
  }
}

export class DDPollOptionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): DDPollOption[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<DDPollOption[]>(value);
  }
}

export class DDVoteLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): DDVote[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<DDVote[]>(value);
  }
}

export class HybridProposalLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): HybridProposal[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<HybridProposal[]>(value);
  }
}

export class HybridPollOptionLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): HybridPollOption[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<HybridPollOption[]>(value);
  }
}

export class HybridVoteLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): HybridVote[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<HybridVote[]>(value);
  }
}

export class ProjectLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Project[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Project[]>(value);
  }
}

export class TaskLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): Task[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<Task[]>(value);
  }
}

export class ValidContractLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): ValidContract[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<ValidContract[]>(value);
  }
}

export class UserLoader extends Entity {
  _entity: string;
  _field: string;
  _id: string;

  constructor(entity: string, id: string, field: string) {
    super();
    this._entity = entity;
    this._id = id;
    this._field = field;
  }

  load(): User[] {
    let value = store.loadRelated(this._entity, this._id, this._field);
    return changetype<User[]>(value);
  }
}
